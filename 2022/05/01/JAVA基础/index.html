

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Cosmo">
  <meta name="keywords" content="">
  
    <meta name="description" content="完结......开设于大二下的学校课程，和我学废了的Java。当时很懂，现在很懵。慢慢修补吧。">
<meta property="og:type" content="article">
<meta property="og:title" content="Java基础">
<meta property="og:url" content="http://example.com/2022/05/01/JAVA%E5%9F%BA%E7%A1%80/index.html">
<meta property="og:site_name" content="Cosmo&#39;s Kingdom">
<meta property="og:description" content="完结......开设于大二下的学校课程，和我学废了的Java。当时很懂，现在很懵。慢慢修补吧。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/TaraTang2003/picgo-typora/main/202205012104998.png">
<meta property="og:image" content="https://raw.githubusercontent.com/TaraTang2003/picgo-typora/main/202205012104339.png">
<meta property="og:image" content="https://raw.githubusercontent.com/TaraTang2003/picgo-typora/main/202205012104485.png">
<meta property="og:image" content="https://raw.githubusercontent.com/TaraTang2003/picgo-typora/main/202204231649083.png">
<meta property="og:image" content="https://raw.githubusercontent.com/TaraTang2003/picgo-typora/main/202205021258617.png">
<meta property="og:image" content="https://raw.githubusercontent.com/TaraTang2003/picgo-typora/main/202205021258829.png">
<meta property="og:image" content="https://raw.githubusercontent.com/TaraTang2003/picgo-typora/main/202204151342217.png">
<meta property="og:image" content="https://raw.githubusercontent.com/TaraTang2003/picgo-typora/main/202204151342650.png">
<meta property="og:image" content="https://raw.githubusercontent.com/TaraTang2003/picgo-typora/main/202204151343389.png">
<meta property="og:image" content="https://raw.githubusercontent.com/TaraTang2003/picgo-typora/main/202204161606148.png">
<meta property="og:image" content="https://raw.githubusercontent.com/TaraTang2003/picgo-typora/main/202204151408667.png">
<meta property="og:image" content="https://raw.githubusercontent.com/TaraTang2003/picgo-typora/main/202204151410680.png">
<meta property="og:image" content="https://raw.githubusercontent.com/TaraTang2003/picgo-typora/main/202204241133141.png">
<meta property="og:image" content="https://raw.githubusercontent.com/TaraTang2003/picgo-typora/main/202204302058604.png">
<meta property="og:image" content="https://raw.githubusercontent.com/TaraTang2003/picgo-typora/main/202204301133811.png">
<meta property="og:image" content="https://raw.githubusercontent.com/TaraTang2003/picgo-typora/main/202204301147925.png">
<meta property="og:image" content="https://raw.githubusercontent.com/TaraTang2003/picgo-typora/main/202204302001137.png">
<meta property="og:image" content="https://raw.githubusercontent.com/TaraTang2003/picgo-typora/main/202205011508683.png">
<meta property="og:image" content="https://raw.githubusercontent.com/TaraTang2003/picgo-typora/main/202204301904900.png">
<meta property="og:image" content="https://raw.githubusercontent.com/TaraTang2003/picgo-typora/main/202204301914543.png">
<meta property="og:image" content="https://raw.githubusercontent.com/TaraTang2003/picgo-typora/main/202204302103384.png">
<meta property="og:image" content="https://raw.githubusercontent.com/TaraTang2003/picgo-typora/main/202205011140298.png">
<meta property="og:image" content="https://raw.githubusercontent.com/TaraTang2003/picgo-typora/main/202205011150048.png">
<meta property="og:image" content="https://raw.githubusercontent.com/TaraTang2003/picgo-typora/main/202205011158914.png">
<meta property="og:image" content="https://raw.githubusercontent.com/TaraTang2003/picgo-typora/main/202205011200655.png">
<meta property="og:image" content="https://raw.githubusercontent.com/TaraTang2003/picgo-typora/main/202205011440920.png">
<meta property="og:image" content="https://raw.githubusercontent.com/TaraTang2003/picgo-typora/main/202205011441915.png">
<meta property="og:image" content="https://raw.githubusercontent.com/TaraTang2003/picgo-typora/main/202205011447855.png">
<meta property="og:image" content="https://raw.githubusercontent.com/TaraTang2003/picgo-typora/main/202205011732179.png">
<meta property="og:image" content="https://raw.githubusercontent.com/TaraTang2003/picgo-typora/main/202205011736156.png">
<meta property="og:image" content="https://raw.githubusercontent.com/TaraTang2003/picgo-typora/main/202205011737373.png">
<meta property="og:image" content="https://raw.githubusercontent.com/TaraTang2003/picgo-typora/main/202206021705205.png">
<meta property="og:image" content="https://raw.githubusercontent.com/TaraTang2003/picgo-typora/main/202206022026456.png">
<meta property="og:image" content="https://raw.githubusercontent.com/TaraTang2003/picgo-typora/main/202205031643788.png">
<meta property="og:image" content="https://raw.githubusercontent.com/TaraTang2003/picgo-typora/main/202206041243441.png">
<meta property="og:image" content="https://raw.githubusercontent.com/TaraTang2003/picgo-typora/main/202206041240865.png">
<meta property="og:image" content="https://raw.githubusercontent.com/TaraTang2003/picgo-typora/main/202206012102665.png">
<meta property="article:published_time" content="2022-05-01T13:06:32.558Z">
<meta property="article:modified_time" content="2023-02-28T08:55:05.300Z">
<meta property="article:author" content="Cosmo">
<meta property="article:tag" content="java">
<meta property="article:tag" content="编程语言">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://raw.githubusercontent.com/TaraTang2003/picgo-typora/main/202205012104998.png">
  
  
  <title>Java基础 - Cosmo&#39;s Kingdom</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.14","typing":{"enable":true,"typeSpeed":60,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 6.1.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Cosmo&#39;s Kingdom</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item dropdown">
              <a class="nav-link dropdown-toggle" target="_self" href="javascript:;" role="button"
                 data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
                <i class="iconfont icon-books"></i>
                查看
              </a>
              <div class="dropdown-menu" aria-labelledby="navbarDropdown">
                
                  
                  
                  
                  <a class="dropdown-item" href="/archives/">
                    
                    归档
                  </a>
                
                  
                  
                  
                  <a class="dropdown-item" href="/categories/">
                    
                    分类
                  </a>
                
                  
                  
                  
                  <a class="dropdown-item" href="/tags/">
                    
                    标签
                  </a>
                
              </div>
            </li>
          
        
          
          
          
          
            <li class="nav-item dropdown">
              <a class="nav-link dropdown-toggle" target="_self" href="javascript:;" role="button"
                 data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
                <i class="iconfont icon-exp-fill"></i>
                乐园
              </a>
              <div class="dropdown-menu" aria-labelledby="navbarDropdown">
                
                  
                  
                  
                  <a class="dropdown-item" href="/books/">
                    
                    书
                  </a>
                
                  
                  
                  
                  <a class="dropdown-item" href="/movies/">
                    
                    影
                  </a>
                
                  
                  
                  
                  <a class="dropdown-item" href="/timeline/">
                    
                    碎碎念
                  </a>
                
              </div>
            </li>
          
        
          
          
          
          
            <li class="nav-item dropdown">
              <a class="nav-link dropdown-toggle" target="_self" href="javascript:;" role="button"
                 data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
                <i class="iconfont icon-map"></i>
                足迹
              </a>
              <div class="dropdown-menu" aria-labelledby="navbarDropdown">
                
                  
                  
                  
                  <a class="dropdown-item" href="/feet/">
                    
                    我的地球
                  </a>
                
                  
                  
                  
                  <a class="dropdown-item" href="/dream/">
                    
                    天马行空
                  </a>
                
              </div>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友链
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="Java基础">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2022-05-01 21:06" pubdate>
        2022年5月1日 晚上
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      27k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      224 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Java基础</h1>
            
              <p class="note note-info">
                
                  本文最后更新于：2023年2月28日 下午
                
              </p>
            
            <div class="markdown-body">
              <h1 id="全局介绍"><a class="markdownIt-Anchor" href="#全局介绍"></a> 全局介绍</h1>
<h2 id="jvmjrejdk"><a class="markdownIt-Anchor" href="#jvmjrejdk"></a> JVM/JRE/JDK</h2>
<p><img src="https://raw.githubusercontent.com/TaraTang2003/picgo-typora/main/202205012104998.png" srcset="/img/loading.gif" lazyload alt="image-20220316094437686" /></p>
<h2 id="命名"><a class="markdownIt-Anchor" href="#命名"></a> 命名</h2>
<ul>
<li>
<p>.xml文件</p>
<ul>
<li>
<p>groupId: 域名（顶级域名.公司.组织.个人.功能板块）</p>
</li>
<li>
<p>artifactId: 功能模块</p>
</li>
</ul>
</li>
<li>
<p>命名规范</p>
<ul>
<li>
<p>包：域名（顶级域名.公司.组织.个人.功能板块）</p>
</li>
<li>
<p>类：大驼峰</p>
</li>
<li>
<p>变量：小驼峰</p>
</li>
<li>
<p>常量：大写下划线连接</p>
</li>
</ul>
</li>
</ul>
<h2 id="机制"><a class="markdownIt-Anchor" href="#机制"></a> 机制</h2>
<ul>
<li>引用机制</li>
</ul>
<p>​		基本数据类型：值传递（不与其它变量共享值)</p>
<p>​		变量：引用传递（传递存储地址）</p>
<ul>
<li>垃圾回收机制</li>
</ul>
<p>​		JRE自动销毁对象释放内存空间</p>
<h1 id="基本语法"><a class="markdownIt-Anchor" href="#基本语法"></a> 基本语法</h1>
<h2 id="关键字fsadt"><a class="markdownIt-Anchor" href="#关键字fsadt"></a> 关键字f/s/a/d/t</h2>
<table>
<thead>
<tr>
<th>关键字</th>
<th>意义</th>
<th>补充</th>
</tr>
</thead>
<tbody>
<tr>
<td>final</td>
<td>声明对象构建之后，值不可变</td>
<td>可用于声明不被继承的类/不被重写的方法/引用不被更改的变量</td>
</tr>
<tr>
<td>static</td>
<td>声明静态域、静态方法</td>
<td>静态域（静态变量/静态常量）：所有对象共享，内存中占一份<br/>静态方法：不需要实例化，可直接调用，与对象无关<br/>静态导入：如<code>import static java.lang.System -&gt; System.out.println = out.println</code>直接使用类的静态方法和静态域</td>
</tr>
<tr>
<td>abstract</td>
<td>抽象类/方法</td>
<td>抽象类：含有一个或多个抽象方法的类，不能创造实例对象，可以被子类继承并重写其抽象方法</td>
</tr>
<tr>
<td>default</td>
<td>默认</td>
<td></td>
</tr>
<tr>
<td>this</td>
<td>当前对象的引用</td>
<td>可以通过this，在实例方法或构造函数中引用当前对象的成员变量</td>
</tr>
</tbody>
</table>
<p>关于抽象类的代码示例：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></div></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">/* Person抽象类中存在 getDescription抽象方法</span><br><span class="hljs-comment">   Person抽象类被Employee、Student子类继承 */</span><br>   <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PersonTest</span><br>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">String</span>[] args)</span></span><br><span class="hljs-function">	</span>&#123;<br>        Person[] people = <span class="hljs-keyword">new</span> Person[<span class="hljs-number">2</span>]; <span class="hljs-comment">//抽象类可创建实例数组，数组中的元素需为非抽象子类实例</span><br>       <br>        people[<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Employee</span>(<span class="hljs-string">&quot;Harry Hacker&quot;</span>, <span class="hljs-number">50000</span>，<span class="hljs-number">1989</span>，<span class="hljs-number">10</span>, <span class="hljs-number">1</span>);<br>        people[<span class="hljs-number">1</span>] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Student</span>(<span class="hljs-string">&quot;Maria Morris&quot;</span>，computer science<span class="hljs-number">&#x27;</span> );<br>        <br>        <span class="hljs-keyword">for</span> (Person p : people)<br>        	System.out.<span class="hljs-built_in">println</span>(p.getNameO + <span class="hljs-string">&quot;, &quot;</span> + p.<span class="hljs-built_in">getDescription</span>());<br>        	<span class="hljs-comment">// 若省略抽象类Person中的getDescription抽象方法，则无法调用p对象的getDescription方法</span><br>	&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> abstract <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span><br>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> abstract <span class="hljs-type">String</span> <span class="hljs-title">getDescription</span><span class="hljs-params">()</span></span>;<br>	<span class="hljs-keyword">private</span> <span class="hljs-type">String</span> name;<br>	<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">(<span class="hljs-type">String</span> name)</span></span><br><span class="hljs-function">	</span>&#123;<br>		<span class="hljs-keyword">this</span>.name = name;<br>	&#125;<br>	<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">String</span> <span class="hljs-title">getName</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>    <span class="hljs-keyword">return</span> name;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Employee</span> extends Person<br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> salary;<br>    <span class="hljs-keyword">private</span> Loca1Date hireDay;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Employee</span><span class="hljs-params">(<span class="hljs-type">String</span> name, <span class="hljs-type">double</span> salary, <span class="hljs-type">int</span> year, <span class="hljs-type">int</span> month, <span class="hljs-type">int</span> day)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-built_in">super</span>(name);<br>        <span class="hljs-keyword">this</span>.salary = salary;<br>        hireDay = LocalDate.<span class="hljs-built_in">of</span>(year, month, day);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title">getSalary</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>    	<span class="hljs-keyword">return</span> salary;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> LocalDate <span class="hljs-title">getHireDay</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>    	<span class="hljs-keyword">return</span> hireDay;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">String</span> <span class="hljs-title">getDescription</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-type">String</span>. format(<span class="hljs-string">&quot;an employee with a salary of $%.2f&quot;</span>, salary);<br>	&#125;<br>	<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">void</span> <span class="hljs-title">raiseSalary</span><span class="hljs-params">(<span class="hljs-type">double</span> byPercent)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">double</span> raise = salary * byPercent / <span class="hljs-number">100</span>;<br>        salary += raise;<br>	&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> extends Person<br>&#123;<br>	<span class="hljs-keyword">private</span> <span class="hljs-type">String</span> major;<br><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(<span class="hljs-type">String</span> name, <span class="hljs-type">String</span> major)</span></span><br><span class="hljs-function">	</span>&#123;<br>		<span class="hljs-built_in">super</span>(name); <br>		<span class="hljs-keyword">this</span>.major = major;<br>	&#125;<br>	<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">String</span> <span class="hljs-title">getDescription</span><span class="hljs-params">()</span></span><br><span class="hljs-function">	</span>&#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;a student majoring in &quot;</span> + major;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="访问限制修饰符"><a class="markdownIt-Anchor" href="#访问限制修饰符"></a> 访问限制修饰符</h2>
<p><code>Access level modifiers</code></p>
<table>
<thead>
<tr>
<th>关键字</th>
<th>意义</th>
<th>补充</th>
</tr>
</thead>
<tbody>
<tr>
<td>public</td>
<td>所有类可见</td>
<td><code>top level</code>，即独立的源文件，只有类/接口/枚举/注解，支持创建为顶级的独立源文件，不存在顶级的方法/变量/常量等</td>
</tr>
<tr>
<td>private</td>
<td>本类可见</td>
<td><code>member level</code>，类的私有静态变量，类的每一个对象内部均可访问，但外部无法访问</td>
</tr>
<tr>
<td>protected</td>
<td>本包/所有子类可见</td>
<td><code>member level</code></td>
</tr>
<tr>
<td>package-private</td>
<td>无修饰符的默认声明，仅本包内可访问</td>
<td><code>top level/ member level</code>，Package级允许源文件名与类型名称不同（但是禁止使用），Public级别则不允许</td>
</tr>
</tbody>
</table>
<h2 id="声明"><a class="markdownIt-Anchor" href="#声明"></a> 声明</h2>
<ul>
<li>
<p>包声明 <code>package</code></p>
</li>
<li>
<p>类声明 <code>class</code></p>
</li>
<li>
<p>方法声明</p>
<p><img src="https://raw.githubusercontent.com/TaraTang2003/picgo-typora/main/202205012104339.png" srcset="/img/loading.gif" lazyload alt="image-20220318105228328" /></p>
<p><strong>方法签名</strong>：方法名称/参数列表（参数个数/参数类型）组成，其不同保证编译成功</p>
<p><strong>方法重载</strong>：同名不同参方法</p>
<ol>
<li>
<p>访问限制修饰符</p>
</li>
<li>
<p>返回值类型</p>
</li>
</ol>
<p>无返回值：void</p>
<ol start="3">
<li>
<p>方法名</p>
</li>
<li>
<p>参数列表</p>
<p>可变长度参数： &lt;数据类型&gt;…</p>
<p><img src="https://raw.githubusercontent.com/TaraTang2003/picgo-typora/main/202205012104485.png" srcset="/img/loading.gif" lazyload alt="image-20220318112205842" /></p>
</li>
<li>
<p>{&lt;代码块&gt;}</p>
</li>
</ol>
</li>
</ul>
<h2 id="数据类型"><a class="markdownIt-Anchor" href="#数据类型"></a> 数据类型</h2>
<p>Java的变量类型分为2种。基本类型（原始类型）和引用类型。</p>
<p>Java提供了8种基本类型。6种数字类型（4个整数型，2个浮点型），1种字符类型，还有1种布尔型。</p>
<ul>
<li>十进制，表示指数 10^2 = e2</li>
<li>十六进制，前缀0x，表示指数 0.125 = 2^-3 = 0x1.0p-3</li>
<li>支持下划线 ‘_’ 分隔提高代码可读性</li>
</ul>
<table>
<thead>
<tr>
<th>Type</th>
<th>Def</th>
<th>Remark</th>
<th>Cate</th>
</tr>
</thead>
<tbody>
<tr>
<td>byte</td>
<td>8位整数</td>
<td></td>
<td>4个整数型</td>
</tr>
<tr>
<td>short</td>
<td>16位整数</td>
<td></td>
<td>4个整数型</td>
</tr>
<tr>
<td>int</td>
<td>32位整数</td>
<td></td>
<td>4个整数型</td>
</tr>
<tr>
<td>long</td>
<td>64位整数</td>
<td>后缀L</td>
<td>4个整数型</td>
</tr>
<tr>
<td>float</td>
<td>单精度浮点</td>
<td>后缀f/F</td>
<td>2个浮点型</td>
</tr>
<tr>
<td>double</td>
<td>双精度浮点</td>
<td>后缀d/D，可省略</td>
<td>2个浮点型</td>
</tr>
<tr>
<td>boolean</td>
<td>布尔</td>
<td>仅具有true/false，无法与0/非0整型替换</td>
<td>1种布尔型</td>
</tr>
<tr>
<td>char</td>
<td>字符</td>
<td>单字符，单引号声明</td>
<td>1种字符类型</td>
</tr>
<tr>
<td>String</td>
<td>字符串</td>
<td>多字符，双引号声明</td>
<td>非基本数据类型，封装类，字符串类型</td>
</tr>
<tr>
<td>enum</td>
<td>枚举</td>
<td>自定义，包含有限个命名的值</td>
<td>非基本数据类型</td>
</tr>
</tbody>
</table>
<p>关于常量（不可变对象）与变量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1. String</span><br>String str=<span class="hljs-string">&quot;abc&quot;</span>;<br>System.out.println(str);<br>str=str+<span class="hljs-string">&quot;de&quot;</span>;<br>System.out.println(str);<br><br><span class="hljs-comment">// 2. StringBuilder</span><br>StringBuilder stringBuilder=<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>().append(<span class="hljs-string">&quot;abc&quot;</span>).append(<span class="hljs-string">&quot;de&quot;</span>);<br>System.out.println(str);<br>System.out.println(stringBuilder.toString());<br></code></pre></td></tr></table></figure>
<p>以上代码的运行逻辑为：</p>
<blockquote>
<p>如果运行这段代码会发现先输出<code>“abc”</code>，然后又输出<code>“abcde”</code>，好像是<code>str</code>这个对象被更改了，其实，这只是一种假象罢了，JVM对于这几行代码是这样处理的，首先创建一个String对象<code>str</code>，并把<code>“abc</code>”赋值给<code>str</code>，然后在第三行中，其实JVM又创建了一个新的对象也名为<code>str</code>，然后再把原来的<code>str</code>的值和<code>“de”</code>加起来再赋值给新的<code>str</code>，而原来的str就会被JVM的垃圾回收机制(GC)给回收掉了，所以，<code>str</code>实际上并没有被更改，也就是前面说的String对象一旦创建之后就不可更改了。所以，Java中对String对象进行的操作实际上是一个不断创建新的对象并且将旧的对象回收的一个过程，所以执行速度很慢。</p>
</blockquote>
<table>
<thead>
<tr>
<th>String的可变数据类型</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>StringBuilder</td>
<td>不支持并发操作，线程不安全，单线程下速度快</td>
</tr>
<tr>
<td>StringBuffer</td>
<td>支持并发操作，线程安全，适用于多线程</td>
</tr>
</tbody>
</table>
<blockquote>
<p>如果一个StringBuffer对象在字符串缓冲区被多个线程使用时，StringBuffer中很多方法可以带有synchronized关键字，所以可以保证线程是安全的，但StringBuilder的方法则没有该关键字，所以不能保证线程安全</p>
</blockquote>
<p>类型转换</p>
<ul>
<li>小向大转换，可直接转换 (例如int to double)</li>
<li>大向小转换，必须声明强制转换 (例如double to int)</li>
</ul>
<p><img src="https://raw.githubusercontent.com/TaraTang2003/picgo-typora/main/202204231649083.png" srcset="/img/loading.gif" lazyload alt="image-20220423164942004" /></p>
<ul>
<li>当操作数的类型不同时，自动向高精度类型转换</li>
</ul>
<h2 id="数组"><a class="markdownIt-Anchor" href="#数组"></a> 数组</h2>
<p>两种创建方式</p>
<ul>
<li>
<p>创建指定长度的空数组（new）</p>
<p><img src="https://raw.githubusercontent.com/TaraTang2003/picgo-typora/main/202205021258617.png" srcset="/img/loading.gif" lazyload alt="image-20220316101920000" /></p>
</li>
<li>
<p>创建确定元素的数组</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/TaraTang2003/picgo-typora/main/202205021258829.png" srcset="/img/loading.gif" lazyload alt="image-20220316102006991" /></p>
<p>多维数组创建</p>
<p><img src="https://raw.githubusercontent.com/TaraTang2003/picgo-typora/main/202204151342217.png" srcset="/img/loading.gif" lazyload alt="image-20220415134242148" /></p>
<p><img src="https://raw.githubusercontent.com/TaraTang2003/picgo-typora/main/202204151342650.png" srcset="/img/loading.gif" lazyload alt="image-20220415134256623" /></p>
<p>多维数组元素访问</p>
<p><img src="https://raw.githubusercontent.com/TaraTang2003/picgo-typora/main/202204151343389.png" srcset="/img/loading.gif" lazyload alt="image-20220415134345359" /></p>
<h2 id="运算符"><a class="markdownIt-Anchor" href="#运算符"></a> 运算符</h2>
<table>
<thead>
<tr>
<th>operations</th>
<th>mean</th>
</tr>
</thead>
<tbody>
<tr>
<td>++i</td>
<td>i +=1; return i</td>
</tr>
<tr>
<td>i++</td>
<td>return i; i +=1</td>
</tr>
<tr>
<td>&amp;&amp;</td>
<td>与</td>
</tr>
<tr>
<td>||</td>
<td>或</td>
</tr>
<tr>
<td>^</td>
<td>异或</td>
</tr>
<tr>
<td>？：</td>
<td>三目运算符（条件判断?真:假）</td>
</tr>
</tbody>
</table>
<h2 id="控制流"><a class="markdownIt-Anchor" href="#控制流"></a> 控制流</h2>
<table>
<thead>
<tr>
<th>statement</th>
<th>use</th>
<th>mean</th>
</tr>
</thead>
<tbody>
<tr>
<td>for</td>
<td>for(初始条件; 终止条件; 循环步长){}</td>
<td>循环</td>
</tr>
<tr>
<td>forEach</td>
<td>for(变量 : 数组){}</td>
<td>增强型循环</td>
</tr>
<tr>
<td>while</td>
<td>while(终止条件){}</td>
<td>循环</td>
</tr>
<tr>
<td>do/while</td>
<td>do{}while(终止条件)</td>
<td>循环</td>
</tr>
<tr>
<td>if/then/else ；if/else</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h1 id="面向对象"><a class="markdownIt-Anchor" href="#面向对象"></a> 面向对象</h1>
<h2 id="关键字"><a class="markdownIt-Anchor" href="#关键字"></a> 关键字</h2>
<table>
<thead>
<tr>
<th>关键字</th>
<th>意义</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>extends</td>
<td>子类 extends 超类</td>
<td></td>
</tr>
<tr>
<td>implements</td>
<td>类 implements 接口</td>
<td></td>
</tr>
<tr>
<td>super</td>
<td>代表当前类的超类，指示编译器调用超类方法/构造器</td>
<td>不能理解为是指向父类的引用，虽然实例化时会调用超类构造函数，但并不会创建超类对象。因此，不存在超类对象。<br/><img src="https://raw.githubusercontent.com/TaraTang2003/picgo-typora/main/202204161606148.png" srcset="/img/loading.gif" lazyload alt="image-20220416160610090" /></td>
</tr>
</tbody>
</table>
<h2 id="构造器"><a class="markdownIt-Anchor" href="#构造器"></a> 构造器</h2>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode">JAVA使用构造器<span class="hljs-comment">(consturctor)</span>这一特殊方法构造实例、初始化对象<br></code></pre></td></tr></table></figure>
<p>构造器的创建</p>
<ul>
<li>编译器自动为没有显式声明构造函数的类，创建一个无参构造函数(no-argument constructor)<br />
但，当类显式声明了有参构造函数，编译器将不再自动创建无参构造函数</li>
<li>一个类可以声明多个构造函数基于不同构造函数创建对象并初始化属性值</li>
<li>在构造函数中，通过super调用超类构造函数语句必须置于构造函数第一行；父类无无参构造函数必须显示调用父类有参构造函数</li>
</ul>
<p>构造器的使用</p>
<ul>
<li>
<p>构造器名字与类名相同，使用时在构造器前面加上 <code>new</code> 操作符构造一个对象</p>
<p><img src="https://raw.githubusercontent.com/TaraTang2003/picgo-typora/main/202204151408667.png" srcset="/img/loading.gif" lazyload alt="image-20220415140850631" /></p>
</li>
<li>
<p>为了构造的对象多次使用，通过变量引用此对象。new操作符为对象分配内存，并返回该对象的内存地址给变量</p>
<p><img src="https://raw.githubusercontent.com/TaraTang2003/picgo-typora/main/202204151410680.png" srcset="/img/loading.gif" lazyload alt="image-20220415141021653" /></p>
</li>
<li>
<p>数组初始化</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">/* 整型 */</span><br><span class="hljs-type">int</span>[] a;  <span class="hljs-comment">//只声明数组a，没有初始化</span><br><span class="hljs-type">int</span>[] a = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">5</span>];  <span class="hljs-comment">//初始化为默认值，int/byte/short/long型为0</span><br><span class="hljs-type">int</span>[] a = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;  <span class="hljs-comment">//初始化为给定值</span><br><span class="hljs-type">int</span>[] a = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[] &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;  <span class="hljs-comment">//初始化为给定值</span><br><span class="hljs-type">int</span>[] a = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">5</span>] &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;  <span class="hljs-comment">//错误，如果提供了数组初始化操作，则不能定义维表达式</span><br><br><span class="hljs-comment">/* 布尔型 */</span> <br><span class="hljs-type">boolean</span>[] boolArray=<span class="hljs-keyword">new</span> <span class="hljs-type">boolean</span>[<span class="hljs-number">5</span>]; <span class="hljs-comment">// 初始化为默认值，bool型为false</span><br><br><span class="hljs-comment">/* 浮点型 */</span><br><span class="hljs-type">double</span>[] doubles = <span class="hljs-keyword">new</span> <span class="hljs-type">double</span>[<span class="hljs-number">5</span>]; <span class="hljs-comment">// 初始化为默认值，float/double型为0.0</span><br></code></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="实例化"><a class="markdownIt-Anchor" href="#实例化"></a> 实例化</h2>
<p>类加载实例化过程（Order of Initialization）</p>
<ol>
<li>
<p>首先，基于类的加载顺序（先加载子类的父类），完成<strong>类的加载</strong></p>
<p>类的加载：执行静态相关操作。即，按顺序初始化static变量（置于堆空间的静态区共享使用），执行static代码块。</p>
</li>
<li>
<p>其次，基于类的加载顺序（先加载子类的父类），执行类中<strong>初始化属性</strong>操作</p>
<p>初始化属性：按顺序执行属性声明及构造函数。</p>
</li>
</ol>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">//示例</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Father</span> &#123;<br>	<span class="hljs-comment">// 父类构造函数</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Father</span>()</span> &#123;<br>		System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;Father: Constructor.&quot;</span>);<br>	&#125;<br>	<br>	<span class="hljs-comment">// 父类静态变量</span><br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String S = create();<br>	<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">create</span>()</span> &#123;<br>		System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;Father: Static method create().&quot;</span>);<br>		<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span><br>	&#125;<br>	<br>	<span class="hljs-comment">// 父类静态方法</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getS</span>()</span> &#123;<br>		System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;Father: Static method getS().&quot;</span>)<br>	&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Son</span> <span class="hljs-title">extends</span> <span class="hljs-title">Father</span> &#123;<br>	<span class="hljs-comment">// 子类构造函数</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Son</span>()</span> &#123;<br>		System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;Son: Constructor.&quot;</span>);<br>	&#125;<br>	<br>	<span class="hljs-comment">// 子类静态代码块</span><br>	<span class="hljs-keyword">static</span> &#123;<br>		System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;Son: Static block.&quot;</span>)<br>	&#125;<br>	<br>	<span class="hljs-comment">// 子类静态方法</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getS</span>()</span> &#123;<br>		System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;Son: Static method getS().&quot;</span>)<br>	&#125;<br>	<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getSon</span>()</span> &#123;<br>		System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;Son: Static method getSon().&quot;</span>)<br>	&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">PropTest</span> &#123;<br>	<span class="hljs-keyword">private</span> Father father;			<span class="hljs-comment">// 仅声明属性，初始化该类时不会加载被声明类</span><br>	<span class="hljs-keyword">private</span> Son son = <span class="hljs-keyword">new</span> Son();	<span class="hljs-comment">// 声明属性被初始化时，初始化该类会依次进行声明类静态相关操作和初始化操作</span><br>	<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Son</span>()</span> &#123;<br>		System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;PropTest: Constructor.&quot;</span>);<br>	&#125;<br>	<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getS</span>()</span> &#123;<br>		System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;PropTest: Static method getS().&quot;</span>)<br>	&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> &#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>)</span> &#123;<br>		<span class="hljs-keyword">new</span> Father(); 	<span class="hljs-comment">// 实例化父类对象，先执行父类static相关操作，再执行构造函数</span><br>		<span class="hljs-keyword">new</span> Son();		<span class="hljs-comment">// 实例化子类对象，先执行父类然后子类static相关操作，再执行父类然后子类的构造函数</span><br>		Father.getS();	<span class="hljs-comment">// 调用父类静态方法，执行父类static相关操作</span><br>		Son.getSon();	<span class="hljs-comment">// 调用子类静态方法，执行父类然后子类static相关操作</span><br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="访问器与更改器"><a class="markdownIt-Anchor" href="#访问器与更改器"></a> 访问器与更改器</h2>
<p>由于对类属性的封装，其数据改变需要编写对外的访问器方法。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">//示例</span><br><span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> speed;<br><span class="hljs-keyword">private</span> <span class="hljs-built_in">bool</span> moving;<br><br><span class="hljs-comment">//getter 获取属性</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">getSpeed</span>()</span>&#123;<br>	<span class="hljs-keyword">return</span> speed<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">1.返回类型与原类型保持一致</span><br><span class="hljs-comment">2.命名规范 get</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">//setter 改变属性</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setSpeed</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> speed</span>)</span>&#123;<br>	<span class="hljs-keyword">return</span> speed<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">isMoving</span>(<span class="hljs-params"><span class="hljs-built_in">bool</span> moving</span>)</span>&#123;<br>	<span class="hljs-keyword">this</span>.moving = moving<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">1.参数类型与原类型保持一致</span><br><span class="hljs-comment">2.命名规范 get/is(bool)</span><br><span class="hljs-comment">3.this指代对象</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
<h2 id="继承"><a class="markdownIt-Anchor" href="#继承"></a> 继承</h2>
<ul>
<li>每个类只能拓展于一个子类</li>
<li>子类必须满足超类特性。因此，逻辑上，能够构造初始化子类的前提，是必须能够构造初始化超类</li>
</ul>
<p>​	<img src="https://raw.githubusercontent.com/TaraTang2003/picgo-typora/main/202204241133141.png" srcset="/img/loading.gif" lazyload alt="image-20220424113333057" /></p>
<ul>
<li>
<p>overriding/hiding：</p>
<p>支持在子类中声明一个与超类中方法签名相同的，新实例方法，从而overriding覆盖超类方法(方法的重写)，重写方法的访问范围，必须大于等于超类声明的范围</p>
<p>支持在子类中声明一个与超类中方法签名相同的，新的静态方法，从而hiding隐藏超类静态方法</p>
</li>
</ul>
<h2 id="多态"><a class="markdownIt-Anchor" href="#多态"></a> 多态</h2>
<p>–作业–</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//此题声明的接口/类，为以下所有选择题提供支持</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">I</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">getI</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-comment">//F 实现 I 接口 </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">F</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">I</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getF</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;F getF&quot;</span>);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getI</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;F getI&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//S 继承 F 父类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">S</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">F</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getS</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;S getS&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getF</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;S getF&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getI</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;S getI&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//没有结果，无法编译/执行的为，错误</span><br></code></pre></td></tr></table></figure>
<h3 id="向上转型"><a class="markdownIt-Anchor" href="#向上转型"></a> 向上转型</h3>
<p><strong>向上转型（upcasting），(隐式转换，implicit casting)</strong></p>
<ul>
<li>隐式的上转型，子类一定具有超类的特性，因此编译器可自动实现类型转换</li>
<li><strong>接口</strong>不能直接实例化，但是可以通过向上转型将其实现类实例化。</li>
<li>向上转型是将子类对象赋给父类引用，限制了子类对象的行为类型，<strong>只能够调用子类重写的方法</strong>。</li>
</ul>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">/*</span><br><span class="hljs-comment">  接口不能直接实例化</span><br><span class="hljs-comment">*/</span><br><br>I i = <span class="hljs-keyword">new</span> <span class="hljs-constructor">I()</span>;<br>i.get<span class="hljs-constructor">I()</span>;<br><span class="hljs-comment">//错误</span><br></code></pre></td></tr></table></figure>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">/*</span><br><span class="hljs-comment">  向上转型 upcasting，</span><br><span class="hljs-comment">  把子类对象赋给父类引用，</span><br><span class="hljs-comment">  即赋值左边为父类 右边为子类。</span><br><span class="hljs-comment">*/</span><br><br>I i = <span class="hljs-keyword">new</span> <span class="hljs-constructor">F()</span>;<br>i.get<span class="hljs-constructor">I()</span>;<br><span class="hljs-comment">//F getI</span><br><span class="hljs-comment">//声明时即向上转型</span><br><br>F f = <span class="hljs-keyword">new</span> <span class="hljs-constructor">F()</span>;<br>I i = f;<br>i.get<span class="hljs-constructor">I()</span>;<br><span class="hljs-comment">//F getI</span><br><span class="hljs-comment">//先声明，后向上转型</span><br></code></pre></td></tr></table></figure>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs abnf">/*<br>  向上转型只能够调用子类重写的方法，<br>  不能调用子类独有方法。<br>*/<br><br>I i <span class="hljs-operator">=</span> new F()<span class="hljs-comment">;</span><br>i.getF()<span class="hljs-comment">;</span><br>//错误<br><br>F f <span class="hljs-operator">=</span> new F()<span class="hljs-comment">;</span><br>I i <span class="hljs-operator">=</span> f<span class="hljs-comment">;</span><br>i.getF()<span class="hljs-comment">;</span><br>//错误<br><br>S s <span class="hljs-operator">=</span> new S()<span class="hljs-comment">;</span><br>F f <span class="hljs-operator">=</span> s<span class="hljs-comment">;</span><br>f.getS()<span class="hljs-comment">;</span><br>//错误<br><br>I i <span class="hljs-operator">=</span> new S()<span class="hljs-comment">;</span><br>i.getI()<span class="hljs-comment">;</span><br>//S getI<br><br>S s <span class="hljs-operator">=</span> new S()<span class="hljs-comment">;</span><br>F f <span class="hljs-operator">=</span>s<span class="hljs-comment">;</span><br>I i <span class="hljs-operator">=</span> f<span class="hljs-comment">;</span><br>i.getI()<span class="hljs-comment">;</span><br>//S getI<br><br>S s <span class="hljs-operator">=</span> new S()<span class="hljs-comment">;</span><br>F f <span class="hljs-operator">=</span> s<span class="hljs-comment">;</span><br>f.getF()<span class="hljs-comment">;</span><br>//S getF<br></code></pre></td></tr></table></figure>
<h3 id="向下转型"><a class="markdownIt-Anchor" href="#向下转型"></a> 向下转型</h3>
<p><strong>向下转型（downcasting），(显式转换，explicit casting)</strong></p>
<ul>
<li>显式的下转型，超类未必一定是子类，因此需显式声明强制转换，且只有运行时才能知道错误</li>
<li>即父类强转子类，是将父类引用的子类对象重新赋给子类引用</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">	向下转型</span><br><span class="hljs-comment">	父类对象不能直接赋给子类引用</span><br><span class="hljs-comment">	只有父类引用的子类对象可以重新赋给子类引用</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-type">F</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">F</span>();<br><span class="hljs-type">S</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> (S) f;<br>s.getS();<br><span class="hljs-comment">//错误</span><br><br><span class="hljs-type">I</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">S</span>(); <span class="hljs-comment">// 子类S的对象赋给父类I的引用</span><br><span class="hljs-type">F</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> (F) i;  <span class="hljs-comment">// 子类S对象的父类I引用赋给子类F的引用</span><br><span class="hljs-type">S</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> (S) f; <span class="hljs-comment">// 子类S对象的父类I引用的子类F的引用赋给子类S的引用</span><br>s.getI(); <span class="hljs-comment">// 本质一直都是子类S的对象</span><br><span class="hljs-comment">//S getI</span><br><br><span class="hljs-type">I</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">F</span>();<br><span class="hljs-type">F</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> (F) i;<br><span class="hljs-type">S</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> (S) f;<br>s.getI();<br><span class="hljs-comment">//错误</span><br><span class="hljs-comment">//本质是子类F的对象 对于F的子类S来说是父类对象 不能向下转型</span><br></code></pre></td></tr></table></figure>
<h2 id="接口"><a class="markdownIt-Anchor" href="#接口"></a> 接口</h2>
<ul>
<li>
<p>一个接口可以扩展自任意数量的接口，一个类可以实现多接口</p>
</li>
<li>
<p>仅可包含方法（抽象方法，默认方法和静态方法）与常量（公有常量）</p>
<ul>
<li>方法与常量默认声明为（无需重复编写）：<code>public static final</code>，可使用<code>default</code>声明默认方法，支持<code>package</code>修饰符(顶级)</li>
</ul>
</li>
<li>
<p>由普通的类来实现接口，必须将接口所有抽象方法重写</p>
<p>由抽象类来实现接口，则接口的方法可根据需要选择是否重写。</p>
<p>继承实现接口的抽象类时，子类必须重写抽象类未实现的方法。</p>
<blockquote>
<p>抽象类的作用即是：<br />
将接口中不需要使用抽象方法交给抽象类完成，这样接口实现类只需要对接口需要方法进行重写，以降低接口实现类对接口实现过程难度</p>
<pre><code class=" mermaid">graph LR;
	Servt实现类 --extends---&gt; HttpServlet抽象类 --extends---&gt; GenericServlet抽象类 --extends---&gt; Servlet接口
</code></pre>
</blockquote>
</li>
<li>
<p>定义了一个接口，就是定义了一个可以引用的类型，像类一样，在任何需要的地方作为类型使用</p>
</li>
<li>
<p>接口不能直接实例化，但是可以通过向上转型将其实现类实例化。</p>
</li>
</ul>
<h2 id="抽象类"><a class="markdownIt-Anchor" href="#抽象类"></a> 抽象类</h2>
<p>抽象类是含有一个或多个抽象方法的类。</p>
<ul>
<li>
<p>抽象类里可以有抽象方法也可以有普通方法</p>
</li>
<li>
<p>抽象类中可以有构造器，但是不能创造实例对象</p>
</li>
<li>
<p>抽象类的子类都必须重写父类中全部的抽象方法，而不必需重写其普通方法</p>
</li>
<li>
<p>抽象方法<code>abstract</code>不能与哪些关键字共存</p>
<blockquote>
<p><code>private</code>：<code>private</code>修饰的方法只能在本类中使用，而抽象方法要求必须让子类实现，两者相互矛盾<br />
<code>final</code>：<code>final</code>修饰的方法不能被重写，而抽象方法必须要被重写，<br />
<code>static</code>：<code>static</code>修饰的方法可以通过类名直接调用，而抽象方法是没有方法体的</p>
</blockquote>
</li>
</ul>
<h2 id="匿名内部类"><a class="markdownIt-Anchor" href="#匿名内部类"></a> 匿名内部类</h2>
<p>匿名内部类，没有名字、不被复用的内部类，通常用来简化代码编写。能够同时的一步到位的，声明和创建一个实现/继承的接口/抽象类的实现类和对象。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// 实例1:抽象类的匿名内部类</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span>()</span>;<br>&#125;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>)</span> &#123;<br>        Person p = <span class="hljs-keyword">new</span> Person() &#123;<br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span>()</span> &#123;<br>                System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;eat something&quot;</span>);<br>            &#125;<br>        &#125;;<br>        p.eat();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 实例2：接口的匿名内部类</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title">Person</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span>()</span>;<br>&#125;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>)</span> &#123;<br>        Person p = <span class="hljs-keyword">new</span> Person() &#123;<br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span>()</span> &#123;<br>                System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;eat something&quot;</span>);<br>            &#125;<br>        &#125;;<br>        p.eat();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h1 id="函数式编程"><a class="markdownIt-Anchor" href="#函数式编程"></a> 函数式编程</h1>
<h2 id="lambda函数"><a class="markdownIt-Anchor" href="#lambda函数"></a> Lambda函数</h2>
<p><strong>匿名函数组成</strong></p>
<p>简写的函数</p>
<p><img src="https://raw.githubusercontent.com/TaraTang2003/picgo-typora/main/202204302058604.png" srcset="/img/loading.gif" lazyload alt="image-20220430205825565" /></p>
<p><strong>匿名函数特点</strong></p>
<ul>
<li>匿名。省略修饰符/返回类型/名称。</li>
<li>函数。不属于任何类，有函数体/（参数列表/返回值）。</li>
<li>传递。匿名函数可作为参数传递给方法，或作为变量的值</li>
</ul>
<p><strong>方法引用</strong></p>
<p>双冒号（<code>::</code>）操作符是 Java 中的<strong>方法引用</strong>。 使用一个方法的引用时，目标引用放在 <code>::</code> 之前，目标引用提供的方法名称放在 <code>::</code> 之后，即 <code>目标引用（类）::方法（类中的方法）</code>。</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">// e.g. 引用Person类中的getAge()方法</span><br>Person::getAge;<br></code></pre></td></tr></table></figure>
<h2 id="函数式接口"><a class="markdownIt-Anchor" href="#函数式接口"></a> 函数式接口</h2>
<p>函数式接口，能且只能包含1个抽象方法的接口。用<code>@FunctionalInterface</code>注解标记（可以省略）。</p>
<p>可以使用Lambda表达式创建一个函数式接口的对象，此对象可以用于传参/赋值，如 Stream/Optional 中的一些方法以函数为参数都是基于函数式接口实现的。</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// 自定义函数式接口</span><br>@FunctionalInterface<br>public interface MyFunction &#123;<br>	<span class="hljs-built_in">int</span> calc<span class="hljs-constructor">Int(<span class="hljs-params">int</span> <span class="hljs-params">x</span>)</span>;<br>&#125;<br><br><span class="hljs-comment">// 函数式接口应用</span><br>public <span class="hljs-keyword">class</span> <span class="hljs-constructor">MyList()</span> &#123;<br>	<span class="hljs-keyword">private</span> List&lt;Integar&gt; <span class="hljs-built_in">list</span>;<br>	public void <span class="hljs-keyword">for</span><span class="hljs-constructor">Each(MyFunction <span class="hljs-params">f</span>)</span> &#123;<br>		<span class="hljs-keyword">for</span> (Intefar i : <span class="hljs-built_in">list</span>) &#123;<br>			<span class="hljs-built_in">int</span> res = f.calc<span class="hljs-constructor">Int(<span class="hljs-params">i</span>)</span>;<br>			<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(res);<br>		&#125;<br>	&#125;<br>&#125;<br><br><span class="hljs-comment">// 应用</span><br>MyList ls = <span class="hljs-keyword">new</span> <span class="hljs-constructor">MyList(List.<span class="hljs-params">of</span>(4,6,7)</span>)<br><span class="hljs-comment">// 1.声明实现函数逻辑的对象</span><br>MyFunction f = x -&gt; return x*x;<br>ls.<span class="hljs-keyword">for</span><span class="hljs-constructor">Each(<span class="hljs-params">f</span>)</span>;<br><span class="hljs-comment">// 2. 直接传入lambda函数</span><br>ls.<span class="hljs-keyword">for</span><span class="hljs-constructor">Each(<span class="hljs-params">x</span> -&gt; <span class="hljs-params">return</span> <span class="hljs-params">x</span><span class="hljs-operator">*</span><span class="hljs-params">x</span>)</span><br></code></pre></td></tr></table></figure>
<h1 id="集合"><a class="markdownIt-Anchor" href="#集合"></a> 集合</h1>
<p>集合是存储元素对象的容器。</p>
<h2 id="集合框架"><a class="markdownIt-Anchor" href="#集合框架"></a> 集合框架</h2>
<p>集合框架，用于表示和操作集合的体系结构，包含</p>
<ul>
<li>接口(Interfaces)：表示集合的抽象数据类型</li>
<li>实现(Implementations)：集合接口的具体实现类，由不同的数据结构实现</li>
<li>算法(Algorithms)：对集合执行搜索/排序等操作</li>
</ul>
<p>即，Java提供了一套包含，多种集合类型，多种数据结构实现，以及操作处理算法的集合框架，供开发人员直接使用</p>
<p><img src="https://raw.githubusercontent.com/TaraTang2003/picgo-typora/main/202204301133811.png" srcset="/img/loading.gif" lazyload alt="image-20220430113343704" /></p>
<h2 id="list"><a class="markdownIt-Anchor" href="#list"></a> LIST</h2>
<pre><code class=" mermaid">graph LR;
0[java.util.List/接口] --基本实现类--- java.util.ArrayList/类
0 --基本实现类--- java.util.LinkedList/类
</code></pre>
<table>
<thead>
<tr>
<th>接口/类</th>
<th>特点</th>
<th>方法</th>
</tr>
</thead>
<tbody>
<tr>
<td>java.util.List<E></td>
<td>有序，允许重复元素<br>集合类型常量不可改变集合结构，如增/删集合元素将引发异常；可以替换元素，元素对象属性值可以改变<br/>集合为逻辑上的容器，容器中仅保存元素对象的引用地址；操作集合中的元素时，实际操作的是元素引用的对象</td>
<td><code>of()</code>：静态方法，返回空列表对象<br/><code>of(elements…)</code>：静态方法，基于指定元素创建集合对象<br/><code>add(int index, E element)</code> : 将元素插入到指定索引处<br/><code>set(int index, E element)</code> ：将指定索引处元素替换<br/><code>get(int index)</code>：获取指定索引处元素<br/><code>getName()</code>：  获取元素名<br/><code>remove(int index)</code>： 移除指定索引处元素<br/><code>toArray(T[] a)</code>：列表转换为数组。创建0长度数组实例即可，方法内部仅将自动调整</td>
</tr>
<tr>
<td>java.util.ArrayList<E></td>
<td>基于对象数组数据结构的实现</td>
<td></td>
</tr>
<tr>
<td>java.util.LinkedList<E></td>
<td>基于双向链表数据结构的实现</td>
<td>为每个元素创建2个节点，保存前/后元素的地址</td>
</tr>
</tbody>
</table>
<p><strong>声明与创建</strong></p>
<p><img src="https://raw.githubusercontent.com/TaraTang2003/picgo-typora/main/202204301147925.png" srcset="/img/loading.gif" lazyload alt="image-20220430114718891" /></p>
<h2 id="set"><a class="markdownIt-Anchor" href="#set"></a> SET</h2>
<p>Set集合，不包含重复元素</p>
<pre><code class=" mermaid">graph LR;
	0[java.util.Map/接口] --基本实现类--- java.util.HashSet/类;
	0 --基本实现类--- java.util.LinkedHashSet/类;
	0 --基本实现类--- java.util.TreeSet/类
</code></pre>
<table>
<thead>
<tr>
<th>接口/类</th>
<th>特点</th>
<th>方法</th>
</tr>
</thead>
<tbody>
<tr>
<td>java.util.Set<E></td>
<td>不包含重复元素，可实现迭代器<br/>添加重复元素不改变集合也不报错<br/>均无基于索引的操作方法</td>
<td>Set.of() 返回空集合对象/集合不可变<br/>Set.of(elements…) 基于指定元素创建集合对象<br/>add(E element))</td>
</tr>
<tr>
<td>java.util.HashSet<E></td>
<td>元素无序</td>
<td>getName() 无序获取</td>
</tr>
<tr>
<td>java.util.LinkedHashSet<E></td>
<td>元素有序</td>
<td></td>
</tr>
<tr>
<td>java.util.TreeSet <E></td>
<td>元素有序</td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="iterator"><a class="markdownIt-Anchor" href="#iterator"></a> ITERATOR</h2>
<p>Iterator接口，迭代器，帮助集合完成遍历与移除，通过移动游标进行操作。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="https://raw.githubusercontent.com/TaraTang2003/picgo-typora/main/202204302001137.png" srcset="/img/loading.gif" lazyload alt="image-20220430200156100" /><br/></td>
<td>获取集合对象的迭代器</td>
</tr>
<tr>
<td><code>next()</code></td>
<td>向后移动游标后，返回游标指向的元素</td>
</tr>
<tr>
<td><code>hasNext()</code></td>
<td>Iterator中是否有下一个元素</td>
</tr>
<tr>
<td><code>remove()</code></td>
<td>从集合移除当前游标指向的元素</td>
</tr>
</tbody>
</table>
<p>示例</p>
<p><img src="https://raw.githubusercontent.com/TaraTang2003/picgo-typora/main/202205011508683.png" srcset="/img/loading.gif" lazyload alt="image-20220501150853634" /></p>
<h2 id="map"><a class="markdownIt-Anchor" href="#map"></a> MAP</h2>
<p>Map不是集合；不继承于Iterable接口，不支持forEach遍历；不支持基于索引的操作</p>
<p><img src="https://raw.githubusercontent.com/TaraTang2003/picgo-typora/main/202204301904900.png" srcset="/img/loading.gif" lazyload alt="image-20220430190455855" /></p>
<pre><code class=" mermaid">graph LR;
	0[java.util.Map/接口] --基本实现类--- java.util.HashMap/类
	0 --基本实现类--- java.util.TreeMap/类
</code></pre>
<table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="https://raw.githubusercontent.com/TaraTang2003/picgo-typora/main/202204301914543.png" srcset="/img/loading.gif" lazyload alt="image-20220430191452490" /></td>
<td>声明与创建，key必须是唯一的，且每个key只能对应一个value。添加key-value时，如果key已经存在，则后一个覆盖前一个</td>
</tr>
<tr>
<td><code>put(K key, V value)</code></td>
<td>保存键值对</td>
</tr>
<tr>
<td><code>get(K key)</code></td>
<td>基于key获取对应的value，如果value不存在，返回null</td>
</tr>
<tr>
<td><code>of(K,V,K,V...)</code></td>
<td>静态方法，基于指定元素创建键值对对象</td>
</tr>
</tbody>
</table>
<h1 id="泛型"><a class="markdownIt-Anchor" href="#泛型"></a> <strong>泛型</strong></h1>
<p>泛型，即**“参数化类型”**，是以类或接口为参数的类型参数，用<code>&lt;&gt;</code>声明，只接受引用类型，不接受基本类型。</p>
<h2 id="泛型类与泛型方法"><a class="markdownIt-Anchor" href="#泛型类与泛型方法"></a> 泛型类与泛型方法</h2>
<p>泛型类</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">GenericsAccept</span>&lt;<span class="hljs-title">T</span>&gt; &#123;<br>  <br>  <span class="hljs-comment">// 类中，T为泛型形参</span><br>  <span class="hljs-keyword">private</span> T t;<br> <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set</span>(<span class="hljs-params">T t</span>)</span> &#123;<br>    <span class="hljs-keyword">this</span>.t = t;<br>  &#125;<br> <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">get</span>()</span> &#123;<br>    <span class="hljs-keyword">return</span> t;<br>  &#125;<br> <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>)</span> &#123;<br>  <br>  	<span class="hljs-comment">// 实例化时，传入泛型的类型实参 Integer/String</span><br>    GenericsAccept&lt;Integer&gt; integerG = <span class="hljs-keyword">new</span> Box&lt;Integer&gt;();<br>    GenericsAccept&lt;String&gt; stringG = <span class="hljs-keyword">new</span> Box&lt;String&gt;();<br> <br>    integerG.<span class="hljs-keyword">add</span>(<span class="hljs-keyword">new</span> Integer(<span class="hljs-number">10</span>));<br>    stringG.<span class="hljs-keyword">add</span>(<span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;菜鸟教程&quot;</span>));<br> <br>    System.<span class="hljs-keyword">out</span>.printf(<span class="hljs-string">&quot;整型值为 :%d\n\n&quot;</span>, integerG.<span class="hljs-keyword">get</span>());<br>    System.<span class="hljs-keyword">out</span>.printf(<span class="hljs-string">&quot;字符串为 :%s\n&quot;</span>, stringG.<span class="hljs-keyword">get</span>());<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">/* 输出</span><br><span class="hljs-comment">整型值为 :10</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">字符串为 :菜鸟教程</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
<p>泛型方法</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> GenericMethod &#123;<br>   // 泛型方法 printArray，&lt;E&gt;为集合类型形参，传入方法的参数由参数类型E[]和参数形参变量名构成                        <br>   <span class="hljs-built_in">public</span> static &lt;E&gt; <span class="hljs-type">void</span> printArray (E[] inputArray) &#123;<br>      // 输出数组元素            <br>         <span class="hljs-keyword">for</span> ( E element : inputArray )&#123;        <br>            <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.printf( &quot;%s &quot;, element );<br>         &#125;<br>         <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println();<br>    &#125;<br> <br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String args[]) &#123;<br>        // 创建不同类型数组： <span class="hljs-type">Integer</span>, <span class="hljs-type">Double</span> 和 <span class="hljs-type">Character</span><br>        <span class="hljs-type">Integer</span>[] intArray = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span> &#125;;<br>        <span class="hljs-type">Double</span>[] doubleArray = &#123; <span class="hljs-number">1.1</span>, <span class="hljs-number">2.2</span>, <span class="hljs-number">3.3</span>, <span class="hljs-number">4.4</span> &#125;;<br>        <span class="hljs-type">Character</span>[] charArray = &#123; <span class="hljs-string">&#x27;H&#x27;</span>, <span class="hljs-string">&#x27;E&#x27;</span>, <span class="hljs-string">&#x27;L&#x27;</span>, <span class="hljs-string">&#x27;L&#x27;</span>, <span class="hljs-string">&#x27;O&#x27;</span> &#125;;<br> <br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println( &quot;整型数组元素为:&quot; );<br>        printArray( intArray  ); // 传递一个整型数组<br> <br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println( &quot;\n双精度型数组元素为:&quot; );<br>        printArray( doubleArray ); // 传递一个双精度型数组<br> <br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println( &quot;\n字符型数组元素为:&quot; );<br>        printArray( charArray ); // 传递一个字符型数组<br>    &#125; <br>&#125;<br><br><span class="hljs-comment">/* 输出</span><br><span class="hljs-comment">整型数组元素为:</span><br><span class="hljs-comment">1 2 3 4 5 </span><br><span class="hljs-comment"></span><br><span class="hljs-comment">双精度型数组元素为:</span><br><span class="hljs-comment">1.1 2.2 3.3 4.4 </span><br><span class="hljs-comment"></span><br><span class="hljs-comment">字符型数组元素为:</span><br><span class="hljs-comment">H E L L O </span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
<h2 id="继承和子类型"><a class="markdownIt-Anchor" href="#继承和子类型"></a> 继承和子类型</h2>
<pre><code class=" mermaid">graph LR;
	0[子类型关系] --- 子类关系;
	0 --- 元素间拥有继承关系的数组
</code></pre>
<p>赋值支持子类型关系，即等号右侧必须是左侧的子类型。</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>&#123;&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> <span class="hljs-keyword"><span class="hljs-keyword">extends</span> <span class="hljs-type">Animal</span></span> </span>&#123;&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> void main(<span class="hljs-keyword">String</span>[] args) &#123;<br>    	<span class="hljs-comment">//编译成功，数组的元素存在继承关系，可通过赋值实现隐式类型转换。</span><br>    	Dog dogs1 = <span class="hljs-keyword">new</span> <span class="hljs-type">Dog</span>[<span class="hljs-number">5</span>];<br>    	 animals1 = <span class="hljs-keyword">new</span> <span class="hljs-type">Animal</span>[<span class="hljs-number">5</span>];<br>    	animals1 = dogs1; <br>    <br>    	<span class="hljs-comment">//编译错误，List&lt;Dog&gt;和List&lt;Animal&gt;平级，均继承自Object类，无子类型关系不得赋值。</span><br>        List&lt;Dog&gt; dogs2 = <span class="hljs-keyword">new</span> <span class="hljs-type">ArrayList</span>&lt;&gt;();<br>        List&lt;Animal&gt; animals2 = <span class="hljs-keyword">new</span> <span class="hljs-type">ArrayList</span>&lt;&gt;();<br>        animals2 = dogs2; <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="通配符"><a class="markdownIt-Anchor" href="#通配符"></a> 通配符</h2>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 为实现 List&lt;Animal&gt; list = new ArrayList&lt;Dog&gt;()，引入通配符</span><br><br><span class="hljs-comment">/* 上界通配符 &lt; ? extends E&gt;</span><br><span class="hljs-comment">   用 extends 声明，表示参数化的类型是指定类型E的子类 */</span><br>   <br><span class="hljs-title class_">List</span>&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span>&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;<span class="hljs-title class_">Dog</span>&gt;()<br><br><span class="hljs-comment">/* 下界通配符 &lt; ? super E&gt;</span><br><span class="hljs-comment">   用 super 声明，表示参数化的类型是指定类型E的父类型，直至 Object */</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ShiftTest</span> &#123;<br>    <span class="hljs-keyword">private</span> &lt;T&gt; <span class="hljs-built_in">void</span> <span class="hljs-title function_">test</span>(<span class="hljs-params">List&lt;? <span class="hljs-variable language_">super</span> T&gt; fatherList, List&lt;T&gt; sonList</span>)&#123;<br>        <span class="hljs-keyword">for</span> (T t : sonList) &#123;<br>            fatherList.<span class="hljs-title function_">add</span>(t);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>) &#123;<br>    <span class="hljs-title class_">List</span>&lt;<span class="hljs-title class_">Dog</span>&gt; dogs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-title class_">List</span>&lt;<span class="hljs-title class_">Animal</span>&gt; animals = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">ShiftTest</span>().<span class="hljs-title function_">test</span>(animals,dogs);<br>&#125;<br><br><br></code></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>通配符/标记符（常用于标记泛型形参）</th>
<th>释义</th>
</tr>
</thead>
<tbody>
<tr>
<td>E</td>
<td>Element (在集合中使用，因为集合中存放的是元素)</td>
</tr>
<tr>
<td>T</td>
<td>Type（类）</td>
</tr>
<tr>
<td>K</td>
<td>Key（键）</td>
</tr>
<tr>
<td>V</td>
<td>Value（值）</td>
</tr>
<tr>
<td>N</td>
<td>Number（数值类型）</td>
</tr>
<tr>
<td>?</td>
<td>不确定类型<br/>不能保证参数一致性，通常用于泛型方法的调用代码和形参，不能用于定义类和泛型方法。</td>
</tr>
</tbody>
</table>
<h1 id="集合流"><a class="markdownIt-Anchor" href="#集合流"></a> 集合流</h1>
<p>集合流不是存储元素的数据结构，而是操作集合元素的管道。仅会对集合中的元素进行操作，不影响源集合结构。</p>
<h2 id="stream"><a class="markdownIt-Anchor" href="#stream"></a> STREAM</h2>
<table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
<th>操作类型</th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="https://raw.githubusercontent.com/TaraTang2003/picgo-typora/main/202204302103384.png" srcset="/img/loading.gif" lazyload alt="image-20220430210353334" /><br/></td>
<td>获取集合对象的集合流</td>
<td>Initial Operations<br/>初始化操作</td>
</tr>
<tr>
<td><code>collect()</code></td>
<td>聚合操作结果</td>
<td>Terminal Operations<br/>终止操作</td>
</tr>
<tr>
<td><img src="https://raw.githubusercontent.com/TaraTang2003/picgo-typora/main/202205011140298.png" srcset="/img/loading.gif" lazyload alt="image-20220501113958190" /><code>forEach()</code></td>
<td>迭代集合流的每个元素</td>
<td>Terminal Operations<br/>终止操作</td>
</tr>
<tr>
<td><img src="https://raw.githubusercontent.com/TaraTang2003/picgo-typora/main/202205011150048.png" srcset="/img/loading.gif" lazyload alt="image-20220501115049997" /><code>filter()</code></td>
<td>基于参数选择集合流中的元素，过滤<br/>参数表达式结果必须为布尔值，为真置于新集合流，为假过滤掉</td>
<td>Intermediate Operations<br/>中间操作</td>
</tr>
<tr>
<td><img src="https://raw.githubusercontent.com/TaraTang2003/picgo-typora/main/202205011158914.png" srcset="/img/loading.gif" lazyload alt="image-20220501115812867" /><img src="https://raw.githubusercontent.com/TaraTang2003/picgo-typora/main/202205011200655.png" srcset="/img/loading.gif" lazyload alt="image-20220501120015607" /><code>map()</code></td>
<td>基于条件将集合流中的元素映射为新类型元素，映射</td>
<td>Intermediate Operations<br/>中间操作</td>
</tr>
<tr>
<td><code>sorted()</code></td>
<td>排序集合流中的元素，排序</td>
<td>Intermediate Operations<br/>中间操作</td>
</tr>
<tr>
<td><code>count()</code></td>
<td>获取集合流中元素个数，计数</td>
<td>Intermediate Operations<br/>中间操作</td>
</tr>
<tr>
<td><code>findFirst()</code></td>
<td>从流中取第一个符合条件元素，封装到<code>Optional</code></td>
<td></td>
</tr>
<tr>
<td><code>java.lang.Comparator</code><br/>Comparator类<img src="https://raw.githubusercontent.com/TaraTang2003/picgo-typora/main/202205011440920.png" srcset="/img/loading.gif" lazyload alt="image-20220501144047875" /><img src="https://raw.githubusercontent.com/TaraTang2003/picgo-typora/main/202205011441915.png" srcset="/img/loading.gif" lazyload alt="image-20220501144115869" /></td>
<td>比较器<br/><code>comparing()</code>，基于参数表达式排序<br/><code>reversed()</code>，倒序</td>
<td>结合<code>sorted()</code></td>
</tr>
<tr>
<td><code>java.util.stream.Collectors</code><br/>Collectors类<br/><img src="https://raw.githubusercontent.com/TaraTang2003/picgo-typora/main/202205011447855.png" srcset="/img/loading.gif" lazyload alt="image-20220501144727820" /></td>
<td>用于操作聚合结果的工具类<br/><code>toList()/toSet()</code>，转换聚合结果为指定数据引用类型<br/><code>groupingBy()</code>，按传入的表达式参数以<code>MAP</code>形式分组<br/><code>toMap(K,V)</code>，基于给定键值以<code>MAP</code>形式分组</td>
<td>结合<code>collect()</code></td>
</tr>
</tbody>
</table>
<h2 id="optional"><a class="markdownIt-Anchor" href="#optional"></a> OPTIONAL</h2>
<p><code>java.util.Optional&lt;T&gt;</code>，为解决空引用异常引入的，用于封装<strong>单值</strong>元素的容器(single-value container)。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
<th>操作类型</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Optional&lt;T&gt; Optional.of(T value)</code></td>
<td>基于必不为空对象，创建optional容器，注入为空元素将抛出NullPointerException异常</td>
<td>Initial Operations<br/>初始化操作</td>
</tr>
<tr>
<td><img src="https://raw.githubusercontent.com/TaraTang2003/picgo-typora/main/202205011732179.png" srcset="/img/loading.gif" lazyload alt="image-20220501173204128" /><code>Optional&lt;T&gt; Optional.ofNullable(T value)</code></td>
<td>基于可能为空的对象，创建optional容器</td>
<td>Initial Operations<br/>初始化操作</td>
</tr>
<tr>
<td><code>ifPresent(action)</code></td>
<td>当optional容器不为空时，执行指定函数；为空忽略执行<img src="https://raw.githubusercontent.com/TaraTang2003/picgo-typora/main/202205011736156.png" srcset="/img/loading.gif" lazyload alt="image-20220501173614108" />仅检测指定元素对象，但嵌套对象为空时依然异常</td>
<td>Intermediate Operations<br/>中间操作</td>
</tr>
<tr>
<td><code>ifPresentOrElse(action, emptyAction)</code></td>
<td>当容器不为空时执行第一个函数；为空执行第二个函数<img src="https://raw.githubusercontent.com/TaraTang2003/picgo-typora/main/202205011737373.png" srcset="/img/loading.gif" lazyload alt="image-20220501173719316" /></td>
<td>Intermediate Operations<br/>中间操作</td>
</tr>
<tr>
<td><code>.filter()</code><br/><code>.map()</code></td>
<td>与Stream中一致</td>
<td>Intermediate Operations<br/>中间操作</td>
</tr>
<tr>
<td><code>.orElse()</code></td>
<td>如果<code>Optional</code>实例有值则将其返回，否则返回<code>orElse</code>方法传入的参数</td>
<td>Terminal Operations<br/>终止操作</td>
</tr>
</tbody>
</table>
<h2 id="操作链"><a class="markdownIt-Anchor" href="#操作链"></a> 操作链</h2>
<p>中间操作执行后，将结果置入一个新集合流，从而允许基于新集合流实现后续操作，形成集合流的操作链。</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// Optional操作链</span><br>Optional&lt;USB&gt; = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Optional</span>.</span></span><span class="hljs-keyword">of</span><span class="hljs-constructor">Nullable(<span class="hljs-params">usb</span>)</span><br>	.map(USB::getVersion)<br>	.ifPresent ( System. out: : println);<br>	<br><span class="hljs-comment">// Stream操作链</span><br>List&lt;Apple&gt; = apples.stream<span class="hljs-literal">()</span><br>	.filter(a -&gt; a.get<span class="hljs-constructor">Weight()</span> &gt;= <span class="hljs-number">50</span>)<br>	.map(a::get<span class="hljs-constructor">Color()</span>)<br>	.collect(collectors.<span class="hljs-keyword">to</span><span class="hljs-constructor">List()</span>);<br></code></pre></td></tr></table></figure>
<h1 id="异常"><a class="markdownIt-Anchor" href="#异常"></a> 异常</h1>
<p>异常，是发生在程序执行过程中的，扰乱了程序正常流程的事件。当方法执行中发生错误时，该方法创建一个对象并将其传递给运行时<code>系统(runtime system)</code>，该对象称为<code>异常对象(exception object)</code>。创建一个异常对象，并将其交给运行时系统，称为<code>抛出异常(throwing an exception)</code>。</p>
<h2 id="异常类型"><a class="markdownIt-Anchor" href="#异常类型"></a> 异常类型</h2>
<p><strong>相关类</strong></p>
<p><img src="https://raw.githubusercontent.com/TaraTang2003/picgo-typora/main/202206021705205.png" srcset="/img/loading.gif" lazyload alt="" /></p>
<h3 id="javalangthrowable类"><a class="markdownIt-Anchor" href="#javalangthrowable类"></a> java.lang.Throwable类</h3>
<p>方法：</p>
<ul>
<li><code>String getMessage()</code>：返回异常信息字符串</li>
<li><code>printStackTrace()</code>：打印异常栈信息</li>
</ul>
<p><strong>类型</strong></p>
<pre><code class=" mermaid">graph LR;
	0[错误/异常类型] --- 1[受检异常Checked Exceptions];
	1 -.- 1.1[程序与程序控制之外的外部资源互交时产生的错误];
	1 -.- 1.2[如文件无法读取/数据库无法访问/网络无法连接等]
	0 --- 2[非受检异常Unchecked Exceptions];
	2 -.- 2.1[程序中的错误逻辑/代码];
	2 -.- 2.2[如空指针异常/数组集合索引越界等];
	0 --- 3[程序错误Error];
	3 -.- 3.1[程序外部在特殊条件下产生];
	3 -.- 3.2[如系统内存溢出/磁盘损坏]
</code></pre>
<h2 id="异常处理"><a class="markdownIt-Anchor" href="#异常处理"></a> 异常处理</h2>
<p><strong>异常处理流程</strong></p>
<ul>
<li>
<p><code>调用栈(Call Stack)</code>：开始于主函数，终止于发生错误的方法的方法列表</p>
</li>
<li>
<p><code>异常处理程序(exception handler)</code>：处理异常的代码块。在调用栈中反序检索得到  (如<code>catch&#123;&#125;</code>)</p>
</li>
<li>
<p><code>捕获异常(catch the exception)</code>：系统在调用栈中找到适当的异常处理程序 (若未找到程序终止)</p>
<p><img src="https://raw.githubusercontent.com/TaraTang2003/picgo-typora/main/202206022026456.png" srcset="/img/loading.gif" lazyload alt="image-20220602202640394" /></p>
</li>
</ul>
<p><strong>显示处理</strong></p>
<p>可能抛出**受检异常(CheckedException)**的方法，必须显式捕获/抛出异常，否则无法编译。</p>
<p>非受检异常(UncheckedException)无需显式捕获处理，将终止程序，直接抛出异常并打印异常栈信息。</p>
<ol>
<li>
<p><code>try catch</code> 显示捕获处理异常</p>
<p>每个catch块都是一个异常处理程序，负责处理指定的异常。</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs fsharp"><span class="hljs-comment">// try-catch 模块</span><br><span class="hljs-keyword">try</span> &#123;<br>	<span class="hljs-comment">// 可能抛出受检异常的代码块</span><br>&#125; catch (ExceptionType name <span class="hljs-operator">|</span> ExceptionType name) &#123;<br>	<span class="hljs-comment">// 出现异常类型1执行的操作</span><br>&#125; catch (ExceptionType name) &#123;<br>	<span class="hljs-comment">// 出现异常类型2执行的操作</span><br>&#125;<br><br><span class="hljs-comment">// 示例</span><br><span class="hljs-keyword">try</span> &#123;<br>	Files.readString(Path.<span class="hljs-keyword">of</span>(path))<br>&#125; catch (IOException e) &#123;<br>	System.out.println(e.getMessage()); <span class="hljs-comment">// 返回异常信息字符串</span><br>	e.printTraceStack;					<span class="hljs-comment">// 打印异常栈信息</span><br>&#125;<br><br><span class="hljs-comment">// finally 模块</span><br><span class="hljs-operator">/*</span> 无异常时，执行<span class="hljs-keyword">try</span>块代码 <span class="hljs-operator">-&gt;</span> 执行<span class="hljs-keyword">finally</span>块代码 <span class="hljs-operator">-&gt;</span> <span class="hljs-keyword">try</span>内<span class="hljs-keyword">return</span>语句 <span class="hljs-operator">/</span> 继续执行块外代码<br>   引发异常时，从<span class="hljs-keyword">try</span>块异常处 <span class="hljs-operator">-&gt;</span> catch块代码 <span class="hljs-operator">-&gt;</span> 执行<span class="hljs-keyword">finally</span>块代码 <span class="hljs-operator">-&gt;</span> catch内<span class="hljs-keyword">return</span>语句 <span class="hljs-operator">/</span>继续执行块外代码<br>   <br>   <span class="hljs-keyword">finally</span>块可用于避免由于方法返回、方法执行异常而意外绕过关闭资源对象代码<br>   仅用于释放资源，禁止参与业务逻辑的处理，块内禁止使用<span class="hljs-keyword">return</span>语句 <span class="hljs-operator">*/</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String getTryCatchFinally() &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 可能抛出受检异常的代码块</span><br>        System.out.println(<span class="hljs-string">&quot;try块内异常前&quot;</span>);<br>        Files.readString(Path.<span class="hljs-keyword">of</span>(path);<br>        System.out.println(<span class="hljs-string">&quot;try块内异常后&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;try中结果”;</span><br><span class="hljs-string">    &#125; catch (IOException e) &#123;</span><br><span class="hljs-string">        // 出现异常类型执行的操作，不出现异常将被忽略</span><br><span class="hljs-string">        System.out.println (&quot;</span>catch块内<span class="hljs-string">&quot;);</span><br><span class="hljs-string">    &#125; finally &#123;</span><br><span class="hljs-string">        //不出现异常，在执行return前，程序将跳转finally模块执行，无return语句时将顺序执行之后的代码</span><br><span class="hljs-string">        System.out.println(&quot;</span><span class="hljs-keyword">finally</span>块内”);<br>    &#125;<br>    System.out.println(<span class="hljs-string">&quot;finally块后”);</span><br><span class="hljs-string">    return &quot;</span><span class="hljs-keyword">finally</span>后结果”;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li>
<p><code>throws/throw</code> 抛出异常</p>
<p>可以在 构造函数/静态方法/实例方法/方法内的代码块/Lambda表达式 等中声明抛出异常</p>
<p><code>throws</code>子句，使当前方法抛出异常，交由调用者处理异常。</p>
<p><code>throw</code>声明，抛出一个异常类的异常实例，跳出当前流程</p>
<p>使用<code>throw</code>抛出受检/自定义异常E，则其所在的函数必须使用<code>throws</code>关键字抛出E或E的父类异常。</p>
<p>构造函数/静态/实例方法/方法内的代码块/Lambda表达式等中可声明抛出异常。其中抽象方法抛出异常时。重写抽象方法的实例方法才可抛出异常。</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-comment">// throws子句 ; throw声明</span><br>methodname <span class="hljs-keyword">throws</span> Exception1,Exception2,..,ExceptionN  &#123;  &#125;  <br><br><span class="hljs-comment">// 示例1</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getThrows</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException</span>&#123;<br>	Files.readString(Path.of(path);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>	<span class="hljs-keyword">try</span> &#123;<br>		getThrows();<br>	&#125; <span class="hljs-keyword">catch</span>(IOException e) &#123;<br>		System.out.println(e.getMessage());<br>	&#125;<br>&#125;<br><br><span class="hljs-comment">// 结合自定义异常 </span><br><span class="hljs-comment">// 自定义异常：通过继承相关异常类实现</span><br><span class="hljs-comment">/*  继承RuntimeException异常类</span><br><span class="hljs-comment">    实现自定义非受检异常</span><br><span class="hljs-comment">    调用RuntimeException构造函数</span><br><span class="hljs-comment">    实现对自定义异常的相关操作 */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RuntimeException</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyException</span> <span class="hljs-params">(String message)</span> </span>&#123;<br>    <span class="hljs-keyword">super</span>(message);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyException</span> <span class="hljs-params">(String message, Throwable cause)</span> </span>&#123;<br>    <span class="hljs-keyword">super</span>(message，cause);<br>	&#125;<br>&#125;<br><br><span class="hljs-comment">// 示例2: 检测异常转非检测异常</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-function">String <span class="hljs-title">shiftException</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        Files.readString(Path.of(path);<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> MyException(<span class="hljs-string">&quot;文件读取错误&quot;</span>, e)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 示例3:</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">divide</span><span class="hljs-params">(<span class="hljs-keyword">double</span> divisor, <span class="hljs-keyword">double</span> dividend)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (dividend == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> MyException(<span class="hljs-string">&quot;被除数为空&quot;</span>); <br>    <span class="hljs-keyword">return</span> divisor / dividend;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="多线程"><a class="markdownIt-Anchor" href="#多线程"></a> 多线程</h1>
<p>进程 (Processes): 操作系统进行资源分配的最小单元，应用程序的执行实例。</p>
<p>线程 (Threads): 进程中的运行实体，操作系统调度的最小任务单位。当程序中所有线程终止，进程随之终止。</p>
<h2 id="线程的创建"><a class="markdownIt-Anchor" href="#线程的创建"></a> 线程的创建</h2>
<ol>
<li>
<p>实现<code>Runnable</code>接口，创建<code>Thread</code>实例，以<code>Runnable</code>实现类实例为构造函数参数</p>
<p>实现线程和任务解耦</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 定义一个实现Runnable接口的任务类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">String</span> name;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">HelloRunnable</span>(<span class="hljs-title class_">String</span> name) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    &#125;<br>	<br>	<span class="hljs-comment">// 根据该线程待执行任务实现run()方法</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">run</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(name + <span class="hljs-string">&quot;线程运行: &quot;</span> + i);<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-title class_">Thread</span>.<span class="hljs-title function_">sleep</span>((int <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * <span class="hljs-number">10</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (<span class="hljs-title class_">InterruptedException</span> e) &#123;<br>                e.<span class="hljs-title function_">printStackTrace</span>();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">getHelloRunnable</span>(<span class="hljs-params"></span>) &#123;<br>	<span class="hljs-comment">// 将Runnable对象基于构造函数传递给Thread对象</span><br>    <span class="hljs-title class_">Thread</span> hr1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">HelloRunnable</span>(<span class="hljs-string">&quot;ThreadA&quot;</span>));<br>    <span class="hljs-title class_">Thread</span> hr2=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">HelloRunnable</span>(<span class="hljs-string">&quot;ThreadB&quot;</span>));<br>    hr1.<span class="hljs-title function_">start</span>();<br>    hr2.<span class="hljs-title function_">start</span>();<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li>
<p>继承<code>Thread</code>类，重写<code>run()</code>方法</p>
<p>线程和任务未解耦</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// 继承Thread类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">HelloThread</span> <span class="hljs-title">extends</span> <span class="hljs-title">Thread</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HelloThread</span>(<span class="hljs-params">String name</span>)</span> &#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>    @Override<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span>()</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            System.<span class="hljs-keyword">out</span>.println(name + <span class="hljs-string">&quot;线程运行: &quot;</span> + i);<br>            <span class="hljs-keyword">try</span> &#123;<br>                sleep((<span class="hljs-built_in">int</span>) Math.random() * <span class="hljs-number">10</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getHelloThread</span>()</span> &#123;<br>	<span class="hljs-comment">// 创建继承Thread类的类的对象</span><br>    HelloThread ht1=<span class="hljs-keyword">new</span> HelloThread(<span class="hljs-string">&quot;ThreadA&quot;</span>);<br>    HelloThread ht2=<span class="hljs-keyword">new</span> HelloThread(<span class="hljs-string">&quot;ThreadB&quot;</span>);<br>    ht1.start();<br>    ht2.start();<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="javalangrunnable接口"><a class="markdownIt-Anchor" href="#javalangrunnable接口"></a> java.lang.Runnable接口</h3>
<p>作用：定义预执行的任务</p>
<p>方法：</p>
<ul>
<li><code>run()</code> : 唯一的抽象方法，需要实现类重写方法时在方法中实现需要线程执行的任务</li>
</ul>
<h2 id="线程的状态"><a class="markdownIt-Anchor" href="#线程的状态"></a> 线程的状态</h2>
<p><img src="https://raw.githubusercontent.com/TaraTang2003/picgo-typora/main/202205031643788.png" srcset="/img/loading.gif" lazyload alt="image-20220503164327678" /></p>
<h3 id="javalangthread类"><a class="markdownIt-Anchor" href="#javalangthread类"></a> java.lang.Thread类</h3>
<p>作用：定义预执行的线程</p>
<p>方法：</p>
<ul>
<li>
<p><code>run()</code>：实现<code>Runnable</code>接口，但重写方法为空，需要继承类时再重写方法，在方法中实现需要线程执行的任务执行完毕后，自动停止线程</p>
</li>
<li>
<p><code>start()</code>：启动线程</p>
</li>
<li>
<p><code>sleep()</code>：静态方法，挂起当前线程，使线程进入非可执行状态，可以通过中断<code>(Interrupt)</code>来终止</p>
</li>
<li>
<p><code>interrupt()</code>：设置中断标识，使指定线程中断，抛出<code>InterruptedException</code>异常 (抛出异常后中断标识清除)</p>
</li>
<li>
<p><code>boolean interrupted()</code>：静态方法，检查当前线程是否中断，返回<code>boolean</code>值，清除中断状态</p>
</li>
<li>
<p><code>join()</code>：当前线程暂停执行，直到指定线程终止，可以通过中断<code>(Interrupt)</code>来终止</p>
</li>
</ul>
<h3 id="javautilconcurrentcountdownlatch类"><a class="markdownIt-Anchor" href="#javautilconcurrentcountdownlatch类"></a> java.util.concurrent.CountDownLatch类</h3>
<p>作用：允许多个线程等待的同步工具</p>
<p>方法：</p>
<ul>
<li><code>countDown()</code>：减少锁计数器的计数，计数达到零则释放所有等待线程</li>
<li><code>await()</code>：当前线程暂停执行直到锁计数器递减到<img src="https://raw.githubusercontent.com/TaraTang2003/picgo-typora/main/202206041243441.png" srcset="/img/loading.gif" lazyload alt="image-20220604124336371" style="zoom: 67%;" /></li>
</ul>
<h2 id="线程同步"><a class="markdownIt-Anchor" href="#线程同步"></a> 线程同步</h2>
<h3 id="synchronized关键字"><a class="markdownIt-Anchor" href="#synchronized关键字"></a> synchronized关键字</h3>
<p>作用对象：</p>
<ul>
<li>
<p>可以作用于类、方法 (包括静态方法)、代码块</p>
</li>
<li>
<p>不得作用于抽象方法、构造函数</p>
</li>
</ul>
<p>作用：修饰部分仅允许一个线程独占访问资源</p>
<h3 id="volatile关键字"><a class="markdownIt-Anchor" href="#volatile关键字"></a> volatile关键字</h3>
<p>作用对象：变量</p>
<p>作用：保证变量的可见性，即各线程不在本地缓存变量副本，每次使用即时从主内存加载变量</p>
<h3 id="javautilconcurrentlockslock接口"><a class="markdownIt-Anchor" href="#javautilconcurrentlockslock接口"></a> java.util.concurrent.locks.Lock接口</h3>
<p>作用：控制多线程访问共享资源的工具，提供比同步操作更广泛、更灵活的锁定操作，提供对共享资源的独占访问权限 (一次只有一个线	        程可以获取该锁)</p>
<p>方法：</p>
<ul>
<li><code>lock()</code> ：锁定任意代码区域 <code>try代码块</code></li>
<li><code>unlock()</code>：操作结束后释放锁 <code>finally代码块</code></li>
</ul>
<p>实现类：<code>ReentrantLock(重入锁)/ReadLock/WriteLock</code></p>
<p><img src="https://raw.githubusercontent.com/TaraTang2003/picgo-typora/main/202206041240865.png" srcset="/img/loading.gif" lazyload alt="image-20220604124016767" /></p>
<h3 id="javautilconcurrentexecutorservice接口"><a class="markdownIt-Anchor" href="#javautilconcurrentexecutorservice接口"></a> java.util.concurrent.ExecutorService接口</h3>
<p>作用：继承于<code>Executor</code>，提供了基于指定线程池策略，创建<code>Executor</code>对象的工厂方法</p>
<p>方法：</p>
<ul>
<li>
<p><code>newSingleThreadExecutor()</code>：创建只有1个工作线程的线程池，串行执行提交的任务</p>
</li>
<li>
<p><code>newFixedThreadPool(int nThreads)</code>：创建固定大小的线程池，每提交一个任务创建一个线程，直到达到指定数量</p>
</li>
<li>
<p><code>execute(Runnable r)</code>：添加执行任务到<code>Executor线程池</code></p>
</li>
<li>
<p><code>shutdown()</code>：禁止添加新任务，等待当前执行中以及任务队列中的所有任务执行完成，关闭线程池</p>
</li>
<li>
<p><code>List&lt;Runnable&gt; shutdownNow()</code>：取消任务队列中需执行的任务，返回未执行任务列表。通过向线程池线程发送 <code>interrupt</code>中断信号，由其中执行的任务捕获处理异常。执行中的任务结束后关闭线程池。</p>
</li>
</ul>
<h3 id="javautilconcurrentatomic包"><a class="markdownIt-Anchor" href="#javautilconcurrentatomic包"></a> java.util.concurrent.atomic包</h3>
<p>作用：实现对特定变量类型的单个变量进行原子操作</p>
<p>包含类：如标量类：AtomicBoolean，AtomicInteger；数组类：AtomicIntegerArray等</p>
<p>方法：<code>get()/set()/increment()</code>：类似在<code>volatile</code>变量上读写</p>
<h3 id="javalangthreadlocalt类"><a class="markdownIt-Anchor" href="#javalangthreadlocalt类"></a> java.lang.ThreadLocal&lt;T&gt;类</h3>
<p>作用：提供线程局部变量，如充当web容器，持有每个请求线程的变量副本</p>
<h1 id="io流"><a class="markdownIt-Anchor" href="#io流"></a> IO流</h1>
<h2 id="io"><a class="markdownIt-Anchor" href="#io"></a> I/O</h2>
<p>IO流，数据源/数据目标、输入/输出的抽象表示</p>
<p><strong>文件的数据形式</strong></p>
<p>数据文件是基于<code>byte(字节)</code>而非<code>bit(位)</code>保存以及传输</p>
<p>1个<code>byte(字节)</code> == 8个二进制<code>bit(位)</code> == 1个255以内的十进制整数</p>
<p>1个<code>char(字符)</code>占的字节与编码有关。英文字符占1个字节；中文字符，在<code>UTF8(Windows 10)</code>中占3个字节，在<code>GBK (Windows 7)</code>中占2个字节</p>
<h3 id="javaioinputstream抽象类"><a class="markdownIt-Anchor" href="#javaioinputstream抽象类"></a> java.io.InputStream抽象类</h3>
<p>输入流</p>
<p>实现子类：FileInputStream，ByteArrayInputStream等</p>
<p><img src="https://raw.githubusercontent.com/TaraTang2003/picgo-typora/main/202206012102665.png" srcset="/img/loading.gif" lazyload alt="image-20220601210226621" /></p>
<p>方法：</p>
<ul>
<li>
<p>构造函数：抛出<code>IOException</code></p>
</li>
<li>
<p><code>int read() throws IOException</code>：抽象方法，由具体子类实现。基于单字节操作，返回流中下一字节的十进制整数形式；到达流末无可读字节，返回-1</p>
<p><code>int read(byte[] b)</code>：字节数组缓冲区，将流中字节读取到字节数组中，第1个字节置入数组[0]…，直到读取到数组长度的字节位置为止；返回读取的字节长度；如果没有可读字节，返回-1</p>
</li>
<li>
<p><code>close() throws IOException</code>：关闭资源</p>
</li>
<li>
<p><code>long transferTo(out) throws IOExecption</code>：直接将输入流中字节转移至输出流，返回总字节长度</p>
</li>
<li>
<p><code>byte[] readAllBytes() throws IOException</code>：将输入流中所有字节读出到字节数组</p>
</li>
</ul>
<h3 id="javaiooutputstream抽象类"><a class="markdownIt-Anchor" href="#javaiooutputstream抽象类"></a> java.io.OutputStream抽象类</h3>
<p>输出流</p>
<p>实现子类同输入流</p>
<p>方法</p>
<ul>
<li>
<p>构造函数：抛出<code>IOException</code></p>
</li>
<li>
<p><code>void write(int b) throws IOException</code> ：抽象方法，基于单字节操作，将十进制整数按字节写入输出</p>
</li>
<li>
<p><code>void write(byte[] b, int off, int len)</code>，从字节数组[off]开始读取，至数组[len]结束</p>
</li>
<li>
<p><code>close() throws IOException</code>：关闭资源</p>
</li>
</ul>
<h2 id="自动关闭"><a class="markdownIt-Anchor" href="#自动关闭"></a> 自动关闭</h2>
<p>完整IO代码</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">implementIO</span>()</span> &#123;<br>	<span class="hljs-comment">// try代码块中进行具体操作前，要将IO流声明为全局变量</span><br>	FileInputStream <span class="hljs-keyword">in</span> = <span class="hljs-literal">null</span>;<br>	FileOutputStream <span class="hljs-keyword">out</span> = <span class="hljs-literal">null</span>;<br>	<br>	<span class="hljs-keyword">try</span> &#123;<br>		<span class="hljs-comment">// 实例化IO流(FileIn/OutputStream从文件系统的文件中读取输入字节)</span><br>		<span class="hljs-keyword">in</span> = FileInputStream(<span class="hljs-string">&quot;D:/input.txt&quot;</span>)<br>		<span class="hljs-keyword">out</span> = FileOutputStream(<span class="hljs-string">&quot;D:/output.txt&quot;</span>)<br>		<br>		<span class="hljs-comment">// 声明存储返回流下一数据的变量、字节缓冲区</span><br>		<span class="hljs-built_in">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-built_in">byte</span>[<span class="hljs-number">4</span>];<br>		<span class="hljs-built_in">int</span> len = <span class="hljs-number">0</span>;<br>		<br>		<span class="hljs-comment">// 从输入流中循环读入长度为4的字节数组覆盖字节缓冲区并写入输出流</span><br>		<span class="hljs-keyword">while</span>((len = <span class="hljs-keyword">in</span>.read(buffer)) != <span class="hljs-number">-1</span>) &#123;<br>			<span class="hljs-keyword">out</span>.write(buffer, <span class="hljs-number">0</span>, len);<br>		&#125;<br>	&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>		e.printStackTrace();<br>	&#125; <span class="hljs-keyword">finally</span> &#123;<br>		<span class="hljs-comment">// 资源对象必须被关闭</span><br>		<span class="hljs-keyword">if</span> (<span class="hljs-keyword">in</span> != <span class="hljs-literal">null</span>) &#123;<br>			<span class="hljs-comment">// close方法抛出io异常</span><br>			<span class="hljs-keyword">try</span> &#123;<br>				<span class="hljs-keyword">in</span>.close()<br>			&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>				e.printStackTrace();<br>			&#125;<br>		&#125;<br>		<span class="hljs-keyword">if</span> (<span class="hljs-keyword">out</span> != <span class="hljs-literal">null</span>) &#123;<br>			<span class="hljs-keyword">try</span> &#123;<br>				<span class="hljs-keyword">out</span>.close()<br>			&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>				e.printStackTrace();<br>			&#125;<br>		&#125;<br>	&#125;<br>	<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="javalangautocloseable接口"><a class="markdownIt-Anchor" href="#javalangautocloseable接口"></a> java.lang.AutoCloseable接口</h3>
<p>任何实现了java.lang.AutoCloseable接口的类型，均是支持自动关闭的资源类型，java.io.Closeable接口继承AutoCloseable接口</p>
<h3 id="try-with-resources语句"><a class="markdownIt-Anchor" href="#try-with-resources语句"></a> try-with-resources语句</h3>
<p>在<code>try()</code>语句中声明需要被关闭的资源，资源将在<code>try&#123;&#125;</code>结束后自动关闭，如：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// 在try()语句中创建资源实例</span><br><span class="hljs-keyword">try</span>(FileInputStream <span class="hljs-keyword">in</span> = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;D:/input.txt&quot;</span>);<br>	FileOutputStream <span class="hljs-keyword">out</span> = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;D:/output.txt&quot;</span>)) &#123;<br>		<span class="hljs-built_in">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-built_in">byte</span>[<span class="hljs-number">4</span>];<br>		<span class="hljs-built_in">int</span> len = <span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">while</span>((len = <span class="hljs-keyword">in</span>.read(buffer)) != <span class="hljs-number">-1</span>) &#123;<br>			<span class="hljs-keyword">out</span>.write(buffer, <span class="hljs-number">0</span>, len);<br>		&#125;<br>	&#125;<br><br><span class="hljs-comment">// 在try()语句外创建资源实例，在语句中声明</span><br>FileInputStream <span class="hljs-keyword">in</span> = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;D:/input.txt&quot;</span>);<br>FileOutputStream <span class="hljs-keyword">out</span> = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;D:/output.txt&quot;</span>);<br><span class="hljs-keyword">try</span>(<span class="hljs-keyword">in</span>; <span class="hljs-keyword">out</span>) &#123;<br>		<span class="hljs-built_in">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-built_in">byte</span>[<span class="hljs-number">4</span>];<br>		<span class="hljs-built_in">int</span> len = <span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">while</span>((len = <span class="hljs-keyword">in</span>.read(buffer)) != <span class="hljs-number">-1</span>) &#123;<br>			<span class="hljs-keyword">out</span>.write(buffer, <span class="hljs-number">0</span>, len);<br>		&#125;<br>	&#125;<br></code></pre></td></tr></table></figure>
<h2 id="文件系统"><a class="markdownIt-Anchor" href="#文件系统"></a> 文件系统</h2>
<p>NIO2 (java8) 将文件路径与文件操作分离，支持异步非阻塞</p>
<h3 id="javaniofilepath接口"><a class="markdownIt-Anchor" href="#javaniofilepath接口"></a> java.nio.file.Path接口</h3>
<p>作用：不依赖于系统的描述文件路径 (即运行在不同操作系统下具体实现不同)</p>
<p>方法</p>
<ol>
<li>
<p>创建：</p>
<ul>
<li>
<p><code>java.nio.file.Paths类</code></p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">Path p <span class="hljs-operator">=</span> Paths.get(<span class="hljs-string">&quot;/tmp/foo&quot;</span>)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>
</li>
<li>
<p><code>Path.of()静态方法</code></p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">Path p <span class="hljs-operator">=</span> Path.of(<span class="hljs-string">&quot;/tmp/foo&quot;</span>)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>获取：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 如 对于路径<span class="hljs-string">&quot;D:/test/input.txt&quot;</span><br></code></pre></td></tr></table></figure>
<ul>
<li>
<p><code>Path getFileName()</code>：返回文件名或名称元素序列的最后一个元素</p>
<p><code>&quot;input.txt&quot;</code></p>
</li>
<li>
<p><code>Path getParent()</code>：返回父目录的路径</p>
<p><code>D:\test</code></p>
</li>
<li>
<p><code>Path getRoot()</code>：返回路径的根</p>
<p><code>D:\</code></p>
</li>
</ul>
</li>
<li>
<p>拼接：</p>
<ul>
<li>
<p><code>Path resolve(Path other)</code>：拼接各级路径</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">Path dir <span class="hljs-operator">=</span> Path.of(<span class="hljs-string">&quot;D:/test&quot;</span>)<span class="hljs-comment">;</span><br>Path file <span class="hljs-operator">=</span> Path.of(<span class="hljs-string">&quot;input.txt&quot;</span>)<span class="hljs-comment">;</span><br>Path p <span class="hljs-operator">=</span> dir.resolve(file)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<h3 id="javaniofilefiles类"><a class="markdownIt-Anchor" href="#javaniofilefiles类"></a> java.nio.file.Files类</h3>
<p>作用：通过丰富的<strong>静态方法</strong>，读取/写入/操作文件与目录</p>
<p>方法（以下方法均为静态方法）：</p>
<ol>
<li>
<p>检查</p>
<ul>
<li><code>boolean exists(Path path) / notExists(Path path)</code>：检查路径是否存在</li>
<li><code>boolean isDirectory(Path path)</code>：检查是否为目录</li>
</ul>
</li>
<li>
<p>创建</p>
<ul>
<li>
<p><code>Path createDirectory(Path dir) throws IOException</code>：创建单级目录，目录路径为多级或已存在则异常</p>
</li>
<li>
<p><code>Path createDirectories(Path dir) throws IOException</code>：创建多级目录</p>
</li>
<li>
<p><code>Path createFile(path) throws IOException</code>：基于指定路径创建文件，文件已存在则异常</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">private</span> static void createFile throws IOException &#123;<br>	Path file = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Path</span>.</span></span><span class="hljs-keyword">of</span>(<span class="hljs-string">&quot;D:/test/input.txt&quot;</span>);<br>	<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Files</span>.</span></span>create<span class="hljs-constructor">Directories(<span class="hljs-params">file</span>.<span class="hljs-params">getParent</span>()</span>);<br>	<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Files</span>.</span></span>create<span class="hljs-constructor">File(<span class="hljs-params">file</span>)</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>复制</p>
<ul>
<li>
<p><code>Path copy(Path source, Path target, CopyOption... options) throws IOException</code>：将文件复制到目标文件，默认如果文件已经存在则异常</p>
<p><code>java.nio.file.StandardCopyOption枚举</code>：实现了<code>CopyOption接口</code>，提供复制选项<code>CopyOption</code></p>
<ul>
<li><code>ATOMIC_MOVE</code>：将文件作为原子文件操作移动 (多线程操作)</li>
<li><code>COPY_ATTRIBUTES</code>：将属性复制到新文件</li>
<li><code>REPLACE_TXISTING</code>：如果文件已存在则替换现有文件</li>
</ul>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> createFile <span class="hljs-keyword">throws</span> IOException &#123;<br>	Path dir = Path.of(<span class="hljs-string">&quot;D:/test&quot;</span>);<br>	Path <span class="hljs-keyword">source</span> = dir.resolve(<span class="hljs-string">&quot;input.txt&quot;</span>);<br>	Path target = dir.resolve(<span class="hljs-string">&quot;output.txt&quot;</span>);<br>	Files.<span class="hljs-keyword">copy</span>(<span class="hljs-keyword">source</span>, target, StandardCopyOption.REPLACE_EXISTING);<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>移动</p>
<ul>
<li><code>Path move(Path source, Path target, CopyOption... options) throws IOException</code>：将文件移动或重命名 (相同目录下) 为目标文件，默认目标文件存在则异常</li>
</ul>
</li>
<li>
<p>删除</p>
<ul>
<li><code>delete(Path path) throws IOException</code>：基于指定路径删除文件/目录，路径不存在/删除目录不为空则异常</li>
<li><code>boolean deleteIfExists(Path path) throws IOException</code>：路径不存在时不删除，返回是否删除成功，删除目录不为空则异常</li>
</ul>
</li>
<li>
<p>遍历</p>
</li>
</ol>
<h1 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h1>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_29122445/article/details/113543903?spm=1001.2101.3001.6650.3&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-3-113543903-blog-118496430.pc_relevant_3mothn_strategy_and_data_recovery&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-3-113543903-blog-118496430.pc_relevant_3mothn_strategy_and_data_recovery&amp;utm_relevant_index=4">Java中的String，StringBuilder，StringBuffer三者的区别</a></li>
</ul>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/java/">java</a>
                    
                      <a class="hover-with-bg" href="/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/05/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">计算机组成原理</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/04/25/%E9%83%A8%E7%BD%B2%E6%9D%82%E8%AE%B0/">
                        <span class="hidden-mobile">部署杂记</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments" lazyload>
                
                  
                
                
  <script type="text/javascript">
    Fluid.utils.loadComments('#comments', function() {
      var light = 'github-light';
      var dark = 'github-light';
      var schema = document.documentElement.getAttribute('data-user-color-scheme');
      if (schema === 'dark') {
        schema = dark;
      } else {
        schema = light;
      }
      window.UtterancesThemeLight = light;
      window.UtterancesThemeDark = dark;
      var s = document.createElement('script');
      s.setAttribute('src', 'https://utteranc.es/client.js');
      s.setAttribute('repo', 'TaraTang2003/utterances-comment');
      s.setAttribute('issue-term', 'pathname');
      
      s.setAttribute('theme', schema);
      s.setAttribute('crossorigin', 'anonymous');
      document.getElementById('comments').appendChild(s);
    })
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> <div style="font-size: 0.85rem"> <span id="timeDate">载入天数...</span> <span id="times">载入时分秒...</span> <script src="/js/duration.js"></script> </div> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            ✨&nbsp总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            💫&nbsp总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
        typing(title);
      
    })(window, document);
  </script>





  

  
    <!-- KaTeX -->
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0/dist/katex.min.css" />
  





  <script  src="https://cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js" ></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize({"theme":"default"});
    }
  </script>







<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
